// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/lc-tut/hdd-music-web/internal/entity"
)

const createMusicRow = `-- name: CreateMusicRow :one
INSERT INTO musics (
    title, midi_file_path
) VALUES (
    $1, $2
) RETURNING id, midi_file_path
`

type CreateMusicRowParams struct {
	Title        string `json:"title"`
	MidiFilePath string `json:"midi_file_path"`
}

type CreateMusicRowRow struct {
	ID           pgtype.UUID `json:"id"`
	MidiFilePath string      `json:"midi_file_path"`
}

func (q *Queries) CreateMusicRow(ctx context.Context, arg CreateMusicRowParams) (CreateMusicRowRow, error) {
	row := q.db.QueryRow(ctx, createMusicRow, arg.Title, arg.MidiFilePath)
	var i CreateMusicRowRow
	err := row.Scan(&i.ID, &i.MidiFilePath)
	return i, err
}

const getMusicMovies = `-- name: GetMusicMovies :many
SELECT title, created_at, updated_at FROM musics
WHERE movie_file_path IS NOT NULL
AND movie_file_path != ''
ORDER BY created_at DESC
`

type GetMusicMoviesRow struct {
	Title     string             `json:"title"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetMusicMovies(ctx context.Context) ([]GetMusicMoviesRow, error) {
	rows, err := q.db.Query(ctx, getMusicMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMusicMoviesRow{}
	for rows.Next() {
		var i GetMusicMoviesRow
		if err := rows.Scan(&i.Title, &i.CreatedAt, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMusicRowByID = `-- name: GetMusicRowByID :many
SELECT id, title, midi_file_path, movie_file_path, created_at, updated_at FROM musics WHERE id = $1
`

func (q *Queries) GetMusicRowByID(ctx context.Context, id pgtype.UUID) ([]entity.Music, error) {
	rows, err := q.db.Query(ctx, getMusicRowByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []entity.Music{}
	for rows.Next() {
		var i entity.Music
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.MidiFilePath,
			&i.MovieFilePath,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMusicMovieFilePath = `-- name: UpdateMusicMovieFilePath :one
UPDATE musics
SET movie_file_path = $2
WHERE id = $1
RETURNING id, movie_file_path
`

type UpdateMusicMovieFilePathParams struct {
	ID            pgtype.UUID `json:"id"`
	MovieFilePath pgtype.Text `json:"movie_file_path"`
}

type UpdateMusicMovieFilePathRow struct {
	ID            pgtype.UUID `json:"id"`
	MovieFilePath pgtype.Text `json:"movie_file_path"`
}

func (q *Queries) UpdateMusicMovieFilePath(ctx context.Context, arg UpdateMusicMovieFilePathParams) (UpdateMusicMovieFilePathRow, error) {
	row := q.db.QueryRow(ctx, updateMusicMovieFilePath, arg.ID, arg.MovieFilePath)
	var i UpdateMusicMovieFilePathRow
	err := row.Scan(&i.ID, &i.MovieFilePath)
	return i, err
}
